package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"time"
)

//  Part 1:
// buying bananas; selling hiding spots; prices only pseudorandom
// Each buyer produces a pseudorandom sequence of secret numbers where each secret is derived from the previous.

// The price the buyer offers is just the 1's digit of each of their secret numbers
//  Num of bananas they are offering in exchange for new hiding spot

// Input:  initial secret number for each buyer
// Output:  sum of 2000th secret number generated by each buyer

//  Part 2:
// Dynamic programming
// -- 1 cache total with running sum -- 1 cache for dedupe within each monkey
//  For each monkey; find sequence of price changes; look back window of 4, find price; add/increment cache; if already exists for this monkey , skip;
//  To summarize, look through global cache and find max key

type secretNumberRound struct {
	secretNum int
	round     int
}

func main() {
	file, err := os.Open("/Users/talmadge.farringer/Documents/side_projects/advent_of_code/2024/problem/puzzleInput/day_22_input.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	startTime := time.Now()
	//secretNumCache := make(map[secretNumberRound]int)
	globalCache := make(map[[4]int]int)
	//partOneAnswer := 0
	partTwoAnswer := 0

	scanner := bufio.NewScanner(file)
	// Go through each monkey
	for scanner.Scan() {
		textString := scanner.Text()
		// Convert string to integer
		secretNum, err := strconv.Atoi(textString)

		// Check for errors
		if err != nil {
			fmt.Println("Error converting string to integer:", err)
		}

		//partOneAnswer += findSecretNum(secretNum, 2000, secretNumCache)

		monkeyCache := make(map[[4]int]int)
		// Lookback window should be the changes in price, NOT the prices
		var lookbackWindow []int
		var prevPrice int
		for i := 0; i < 2000; i++ {
			currentPrice := secretNum % 10
			if i == 0 {
				lookbackWindow = append(lookbackWindow, currentPrice)
			} else {
				lookbackWindow = append(lookbackWindow, currentPrice-prevPrice)
			}
			if i > 3 {
				//  Drop the first element
				lookbackWindow = lookbackWindow[1:]
				var fixedLookBack [4]int
				copy(fixedLookBack[:], lookbackWindow)
				//	Check cache
				_, exists := monkeyCache[fixedLookBack]
				if exists {
					//continue
				} else {
					if currVal, ok := globalCache[fixedLookBack]; ok {
						//	Profit from sale is the most recent value
						globalCache[fixedLookBack] = currVal + currentPrice
						monkeyCache[fixedLookBack] = currentPrice
					} else {
						//  Otherwise add to the global map
						globalCache[fixedLookBack] = currentPrice
						monkeyCache[fixedLookBack] = currentPrice
					}
				}
			}
			prevPrice = currentPrice
			secretNum = findNextNum(secretNum)
		}
	}

	for _, value := range globalCache {
		if value > partTwoAnswer {
			partTwoAnswer = value
			//fmt.Println("Highest key: %s; value: %s", key, value)
		}
	}

	elapsedTime := time.Since(startTime)
	fmt.Printf("Program took %s to run\n", elapsedTime)
	//log.Printf("Part 1 answer: %d", partOneAnswer)
	log.Printf("Part 2 answer: %d", partTwoAnswer)
}

func findNextNum(secretNum int) int {
	var newSecretNum int

	newSecretNum = mix(secretNum, secretNum*64)
	newSecretNum = prune(newSecretNum)

	newSecretNum = mix(newSecretNum, newSecretNum/32)
	newSecretNum = prune(newSecretNum)

	newSecretNum = mix(newSecretNum, newSecretNum*2048)
	newSecretNum = prune(newSecretNum)

	return newSecretNum
}

func findSecretNum(secretNum int, roundCount int, cache map[secretNumberRound]int) int {
	var newSecretNum int

	if roundCount == 0 {
		// No rounds left return itself
		return secretNum
	}

	//  Already saw this entry
	cacheValue, exists := cache[secretNumberRound{secretNum, roundCount}]
	if exists {
		return cacheValue
	}

	newSecretNum = mix(secretNum, secretNum*64)
	newSecretNum = prune(newSecretNum)

	newSecretNum = mix(newSecretNum, newSecretNum/32)
	newSecretNum = prune(newSecretNum)

	newSecretNum = mix(newSecretNum, newSecretNum*2048)
	newSecretNum = prune(newSecretNum)

	cache[secretNumberRound{secretNum, roundCount}] = newSecretNum
	return findSecretNum(newSecretNum, roundCount-1, cache)
}

func prune(x int) int {
	return x % 16777216
}

func mix(x int, y int) int {
	return x ^ y
}
